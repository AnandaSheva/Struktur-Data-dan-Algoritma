# -*- coding: utf-8 -*-
"""Tugas(array based sequenced)_2217051096_Ananda Sheva Hidayat_B.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Na5rRB1Lfl-SwV8HPUE9X2tRx5Zk-gOs

**R-5.1** Execute the experiment from Code fragment 5.1 and compare the results on your system to those we report in Code fragment 5.2
"""

import sys 
n = 27
data = []
for k in range(n): 
  a = len(data) 
  b = sys.getsizeof(data) 
  print('Length: {0:3d}; Size in bytes: {1:4d}' .format(a, b))
  data.append(None)

"""**R-5.2** Code Fragment 5.1, we perform an experiment to compare the length of a Python list to its underlying memory usage. Determining the sequence of array sizes requires a manual inspection of the output of that program. Redesign the experiment so that the program outputs only those values of k at which the existing capacity is exhausted. For example, on a system consistent with the results of Code Fragment 5.2, your program should output that the sequence of array capacities are 0, 4, 8, 16, 25, ...."""

import sys

if __name__== '__main__':
  data = []
  prev_size = sys.getsizeof(data)

  for k in range (n):
    a = len(data)
    b = sys.getsizeof(data)
    if b != prev_size:
      print('Length; {0:3d}; Size in bytes: {1:4d}'. format(a-1,b))
      prev_size = b
    data.append(None)

"""**R-5.3** the experiment from the program above in order to demonstrate that Python's list class occasionally shrinks the size of its underlying array when elements are popped from a list"""

import sys


def array_grow_shrink(n, lower_limit = 0.2):
    data = []
    size_old = 0
    current_limit = 10
    for i in range(n):
        if i == current_limit:
            while len(data)> current_limit*lower_limit:
                data.pop()
                size = sys.getsizeof(data)
                print(len(data), size, end = '\t\t')
                if size<size_old:
                    print ('Size decreased from:', size_old, size)
                else: print("")
                size_old = size
            current_limit *= 10
        data.append(None)
        
        
array_grow_shrink(1000)

"""**R-5.4** Our DynamicArray class, as given in Code Fragment 5.3, does not support use of negative indices with __getitem__. Update that method to better match the semantics of a Python list"""

import ctypes

class DynamicArray:
    def __init__(self):
        self._n = 0
        self._capacity = 0
        self._A = self._make_array(self._capacity)

    def __len__(self):
        return self._n

    def __getitem__(self, k):
        if isinstance(k, int):
            if k < 0:
                k += self._n  # Convert negative index to positive
            if not 0 <= k < self._n:
                raise IndexError('Invalid index')
            return self._A[k]
        else:
            raise TypeError('Invalid index type')

    def append(self, obj):
        if self._n == self._capacity:
            self._resize(2 * self._capacity)
        self._A[self._n] = obj
        self._n += 1

    def _resize(self, c):
        B = self._make_array(c)
        for k in range(self._n):
            B[k] = self._A[k]
        self._A = B
        self._capacity = c

    def _make_array(self, c):
        return (c * ctypes.py_object)()

"""**R-5.5** Redo the justification of Proposition 5.1 assuming that the the cost of growing the array from size k to size 2k is 3k cyber-dollars. How much should each append operation be charged to make the amortization work?"""

import sys
import math

n = 27
data = []
c = 0  
f = 0  

for k in range(n):
    a = len(data)
    b = sys.getsizeof(data)
    print('Length: {0:3d}; Size in bytes: {1:4d}'.format(a, b))

    if a == f:
        c = f
        f = 2 * c
        total_cost_resizing = 3 * (f - c)
    
    data.append(None)

amortized_cost = (n - total_cost_resizing) / n

print("Amortized cost per append operation: {:.2f} cyber-dollars".format(amortized_cost))

"""**R-5.6**Our implementation of insert for the DynamicArray class, as given in Code Fragment 5.5, has the following inefficiency. In the case when a resize occurs, the resize operation takes time to copy all the elements from an old array to a new array, and then the subsequent loop in the body of insert shifts many of those elements. Give an improved implementation of the insert method, so that, in the case of a resize, the elements are shifted into their final position during that operation, thereby avoiding the subsequent shifting"""

def insert(self, k, value):
    if self._n == self._capacity:
        self._resize(2 * self._capacity)
    
    if k < 0 or k > self._n:
        raise IndexError('Invalid index')

    if k < self._n:
        for j in range(self._n - 1, k - 1, -1):
            self._A[j + 1] = self._A[j]

    self._A[k] = value
    self._n += 1